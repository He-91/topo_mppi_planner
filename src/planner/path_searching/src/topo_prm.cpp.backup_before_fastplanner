#include "path_searching/topo_prm.h"
#include <cmath>
#include <algorithm>
#include <fstream>
#include <chrono>    // ğŸš€ P0: æ·»åŠ æ—¶é—´æµ‹é‡æ”¯æŒ
#include <sstream>   // ğŸ¨ å¯è§†åŒ–: å­—ç¬¦ä¸²æ ¼å¼åŒ–
#include <iomanip>   // ğŸ¨ å¯è§†åŒ–: æ•°å­—æ ¼å¼åŒ–

using namespace std;
using namespace Eigen;

namespace ego_planner {

TopoPRM::TopoPRM() 
    : step_size_(0.2), search_radius_(5.0), max_sample_num_(1000), 
      collision_check_resolution_(0.2),  
      max_raw_paths_(15),               // DFSæ—©åœé™åˆ¶ (vs FPçš„300)
      reserve_num_(6),                  // ä¿ç•™6æ¡æœ€çŸ­è·¯å¾„ (ä¸FPä¸€è‡´)
      clearance_(0.35),                 // âœ… 0.5â†’0.35m (å‚è€ƒFPçš„0.3m,å¹³è¡¡å®‰å…¨ä¸é‡‡æ ·)
      sample_inflate_(1.5),             // âœ… 2.0â†’1.5m (é¿å…è¿‡åº¦é‡‡æ ·,å‚è€ƒFPçš„1.0-3.5èŒƒå›´)
      ratio_to_short_(3.0),             // âœ… 2.0â†’3.0 (æ”¾å®½è‡³3å€,å¹³è¡¡å¤šæ ·æ€§,FPç”¨5.5)
      discretize_points_num_(25) {      // æ‹“æ‰‘å»é‡ç¦»æ•£åŒ–25ç‚¹ (ä¸¥æ ¼å»é‡)
}

TopoPRM::~TopoPRM() {
    clearGraph();
}

void TopoPRM::clearGraph() {
    for (auto node : graph_nodes_) {
        delete node;
    }
    graph_nodes_.clear();
    raw_paths_.clear();
}

void TopoPRM::init(ros::NodeHandle& nh, GridMap::Ptr grid_map) {
    grid_map_ = grid_map;
    topo_paths_pub_ = nh.advertise<visualization_msgs::MarkerArray>("/topo_paths", 10);
    // ğŸ”§ /topo_paths_smoothç”±planner_managerå‘å¸ƒ,é¿å…å¾ªç¯ä¾èµ–
    
    // Get frame_id from node parameter, default to "world" if not set
    nh.param("grid_map/frame_id", frame_id_, std::string("world"));
    
    ROS_INFO("[TopoPRM] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    ROS_INFO("[TopoPRM] ğŸš€ TOPO-PRM OPTIMIZED CONFIG v4.3 (Fast-Planner Tuned):");
    ROS_INFO("[TopoPRM]   ğŸ“Š é‡‡æ ·: æ¤­çƒ50+è¾¹ç•Œ20=70ç‚¹");
    ROS_INFO("[TopoPRM]   ğŸ•¸ï¸  å›¾æ„å»º: KNN K=12 (å¹³è¡¡è¿é€šæ€§)");
    ROS_INFO("[TopoPRM]   ğŸ” DFSç­–ç•¥: æ—©åœ15æ¡@400ms, æ·±åº¦â‰¤15");
    ROS_INFO("[TopoPRM]   ğŸ¯ å‚æ•°ä¼˜åŒ–: clearance=%.2fm (vs FP 0.3m)", clearance_);
    ROS_INFO("[TopoPRM]                 inflate=%.1fm (vs FP 1.0-3.5m)", sample_inflate_);
    ROS_INFO("[TopoPRM]                 ratio=%.1f (vs FP 5.5)", ratio_to_short_);
    ROS_INFO("[TopoPRM]   ğŸ¨ å¯è§†åŒ–: /topo_paths (åŸå§‹æŠ˜çº¿,æœ¬æ¨¡å—)");
    ROS_INFO("[TopoPRM]                 /topo_paths_smooth (B-spline,ç”±plan_manageå‘å¸ƒ)");
    ROS_INFO("[TopoPRM]   ğŸ¯ ç›®æ ‡: è·¯å¾„æ•°5-6æ¡, waypoints<25, å•è·¯å¾„ç‡<8%%");
    ROS_INFO("[TopoPRM] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
}

bool TopoPRM::searchTopoPaths(const Vector3d& start, const Vector3d& goal,
                             vector<TopoPath>& topo_paths) {
    topo_paths.clear();
    
    ROS_INFO("[TopoPRM] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    ROS_INFO("[TopoPRM] ğŸš€ Fast-Planner PRM: [%.2f,%.2f,%.2f] â†’ [%.2f,%.2f,%.2f]", 
             start.x(), start.y(), start.z(), goal.x(), goal.y(), goal.z());
    
    // âœ… GLOBAL FIX: é‡‡æ ·ä¼˜åŒ– - ç²¾å‡†æ¤­çƒé‡‡æ ·é¿å…ç»•è·¯
    ROS_INFO("[TopoPRM] STEP 1: å¤šå±‚è‡ªç”±ç©ºé—´é‡‡æ ·...");
    // Layer 1: æ¤­çƒæ ¸å¿ƒé‡‡æ · (50ç‚¹ - é™ä½ä»¥é¿å…è¿‡å¹¿é‡‡æ ·)
    vector<Vector3d> sample_points = sampleFreeSpaceInEllipsoid(start, goal, 50);
    int ellipsoid_count = sample_points.size();
    
    // Layer 2: è¾¹ç•Œå±‚é‡‡æ · (20ç‚¹)
    vector<Vector3d> boundary_points = sampleBoundaryLayer(start, goal, 20);
    sample_points.insert(sample_points.end(), boundary_points.begin(), boundary_points.end());
    
    ROS_INFO("[TopoPRM]   é‡‡æ ·åˆ° %zu ä¸ªæœ‰æ•ˆç‚¹ (æ¤­çƒ:%d + è¾¹ç•Œ:%zu)", 
             sample_points.size(), ellipsoid_count, boundary_points.size());
    
    if (sample_points.size() < 10) {
        ROS_ERROR("[TopoPRM] é‡‡æ ·å¤±è´¥: ä»…%zuä¸ªç‚¹ï¼Œæ— æ³•æ„å»ºPRMå›¾", sample_points.size());
        return false;
    }
    
    // Step 2: æ„å»ºå¯è§æ€§å›¾ (Week 2)
    ROS_INFO("[TopoPRM] STEP 2: æ„å»ºå¯è§æ€§å›¾...");
    buildVisibilityGraph(start, goal, sample_points);
    ROS_INFO("[TopoPRM]   å›¾èŠ‚ç‚¹æ•°: %zu", graph_nodes_.size());
    
    if (graph_nodes_.size() < 3) {
        ROS_ERROR("[TopoPRM] å›¾æ„å»ºå¤±è´¥: ä»…%zuä¸ªèŠ‚ç‚¹ï¼Œæ— æ³•è¿›è¡Œè·¯å¾„æœç´¢", graph_nodes_.size());
        clearGraph();
        return false;
    }
    
    // Step 3: DFSå¤šè·¯å¾„æœç´¢ (Week 3)
    ROS_INFO("[TopoPRM] STEP 3: DFSå¤šè·¯å¾„æœç´¢...");
    GraphNode* start_node = graph_nodes_[0];
    GraphNode* goal_node = graph_nodes_[1];
    vector<vector<Vector3d>> raw_paths = searchMultiplePaths(start_node, goal_node);
    ROS_INFO("[TopoPRM]   åŸå§‹è·¯å¾„æ•°: %zu", raw_paths.size());
    
    if (raw_paths.empty()) {
        ROS_ERROR("[TopoPRM] DFSæœç´¢å¤±è´¥: æœªæ‰¾åˆ°å¯è¡Œè·¯å¾„");
        clearGraph();
        return false;
    }
    
    // Step 4: æ‹“æ‰‘å»é‡ (Week 4)
    ROS_INFO("[TopoPRM] STEP 4: æ‹“æ‰‘ç­‰ä»·æ€§å»é‡...");
    vector<vector<Vector3d>> unique_paths = pruneEquivalentPaths(raw_paths);
    ROS_INFO("[TopoPRM]   å»é‡åè·¯å¾„æ•°: %zu", unique_paths.size());
    
    // Step 5: é€‰æ‹©æœ€çŸ­è·¯å¾„
    ROS_INFO("[TopoPRM] STEP 5: é€‰æ‹©æœ€ä¼˜è·¯å¾„...");
    vector<vector<Vector3d>> selected_paths = selectShortPaths(unique_paths);
    ROS_INFO("[TopoPRM]   æœ€ç»ˆé€‰æ‹©: %zu æ¡è·¯å¾„", selected_paths.size());
    
    // è½¬æ¢ä¸ºTopoPathæ ¼å¼
    for (size_t i = 0; i < selected_paths.size(); ++i) {
        double cost = calculatePathCost(selected_paths[i]);
        topo_paths.emplace_back(selected_paths[i], cost, i);
    }
    
    ROS_INFO("[TopoPRM] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    ROS_INFO("[TopoPRM] ğŸ“Š PRMæœç´¢æ€»ç»“:");
    ROS_INFO("[TopoPRM]   é‡‡æ ·ç‚¹: %zu", sample_points.size());
    ROS_INFO("[TopoPRM]   åŸå§‹è·¯å¾„: %zu", raw_paths.size());
    ROS_INFO("[TopoPRM]   å”¯ä¸€è·¯å¾„: %zu", unique_paths.size());
    ROS_INFO("[TopoPRM]   æœ€ç»ˆè·¯å¾„: %zu", topo_paths.size());
    ROS_INFO("[TopoPRM]   ğŸ¯ å¤šè·¯å¾„è§¦å‘: %s", 
             topo_paths.size() > 1 ? "âœ… YES (MPPI will run!)" : "âŒ NO");
    ROS_INFO("[TopoPRM] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    // ğŸ¨ åŸå§‹æŠ˜çº¿å¯è§†åŒ– (B-splineå¹³æ»‘ç”±plan_manageå¤„ç†,é¿å…å¾ªç¯ä¾èµ–)
    visualizeTopoPaths(topo_paths);
    
    // Cleanup
    clearGraph();
    
    return !topo_paths.empty();
}

// ============================================================================
// ğŸ”§ LEGACY TOPOLOGICAL PLANNING CODE - COMMENTED OUT FOR TESTING
// ============================================================================
// This entire section (findTopoPaths and 4 path generators) is disabled
// during TGK system validation. Will be permanently removed after testing.
// Backup: topo_prm.cpp.backup_before_legacy_removal
// ============================================================================


// ============================================================================
// ğŸš€ FAST-PLANNER PRM IMPLEMENTATION (Week 1-4)
// ============================================================================

// ============================================================================
// Week 1: æ¤­çƒè‡ªç”±ç©ºé—´é‡‡æ ·
// ============================================================================
vector<Vector3d> TopoPRM::sampleFreeSpaceInEllipsoid(const Vector3d& start, 
                                                     const Vector3d& goal, 
                                                     int num_samples) {
    vector<Vector3d> free_points;
    
    Vector3d center = 0.5 * (start + goal);
    double semi_major_axis = 0.5 * (goal - start).norm() + sample_inflate_;
    
    // æ„å»ºæ¤­çƒåæ ‡ç³»
    Vector3d x_axis = (goal - start).normalized();
    Vector3d z_axis(0, 0, 1);
    Vector3d y_axis = x_axis.cross(z_axis).normalized();
    if (y_axis.norm() < 1e-3) {
        y_axis = Vector3d(1, 0, 0);
    }
    z_axis = x_axis.cross(y_axis).normalized();
    
    Matrix3d rotation;
    rotation.col(0) = x_axis;
    rotation.col(1) = y_axis;
    rotation.col(2) = z_axis;
    
    // éšæœºé‡‡æ ·
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    int valid_count = 0;
    int attempts = 0;
    int max_attempts = num_samples * 10;  // æœ€å¤šå°è¯•10å€
    
    // ğŸš€ OPTIMIZED: æ”¶é›†è¢«æ‹’ç»çš„ç‚¹ï¼ˆé è¿‘éšœç¢ï¼‰ç”¨äºè¾¹ç¼˜é‡‡æ ·
    vector<Vector3d> rejected_points;
    
    while (valid_count < num_samples && attempts < max_attempts) {
        attempts++;
        
        // åœ¨æ¤­çƒå†…å‡åŒ€é‡‡æ ·
        double theta = 2.0 * M_PI * dis(gen);
        double phi = acos(2.0 * dis(gen) - 1.0);
        double r = pow(dis(gen), 1.0/3.0) * semi_major_axis;
        
        Vector3d pt_local(
            r * sin(phi) * cos(theta),
            r * sin(phi) * sin(theta),
            r * cos(phi)
        );
        
        Vector3d pt_world = rotation * pt_local + center;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨è‡ªç”±ç©ºé—´
        if (isPointFree(pt_world, clearance_)) {
            free_points.push_back(pt_world);
            valid_count++;
        } else {
            // æ”¶é›†è¢«æ‹’ç»çš„ç‚¹ç”¨äºåç»­è¾¹ç¼˜é‡‡æ ·
            rejected_points.push_back(pt_world);
        }
    }
    
    // ğŸš€ OPTIMIZED: æ·»åŠ éšœç¢è¾¹ç¼˜é‡‡æ ·
    // TODO: generateTangentPointså‡½æ•°æš‚æœªå®ç°ï¼Œå…ˆæ³¨é‡Šæ‰
    // int edge_samples = min(50, (int)rejected_points.size());  // æœ€å¤š50ä¸ªè¾¹ç¼˜é‡‡æ ·
    // for (int i = 0; i < edge_samples; ++i) {
    //     Vector3d obs_center = rejected_points[i];
    //     vector<Vector3d> tangents = generateTangentPoints(start, goal, obs_center);
    //     for (const auto& tangent : tangents) {
    //         if (isPointFree(tangent, clearance_)) {
    //             free_points.push_back(tangent);
    //         }
    //     }
    // }
    
    ROS_DEBUG("[TopoPRM] æ¤­çƒé‡‡æ ·: %d æ¬¡å°è¯•, %d ä¸ªæœ‰æ•ˆç‚¹", attempts, valid_count);
    
    return free_points;
}

// ğŸš€ P0 NEW FUNCTION: è¾¹ç•Œå±‚é‡‡æ ·
// åœ¨æ¤­çƒè¾¹ç¼˜ï¼ˆshellï¼‰é‡‡æ ·ï¼Œå¢åŠ è¿œç«¯å’Œä¾§å‘è¿é€šæ€§
vector<Vector3d> TopoPRM::sampleBoundaryLayer(const Vector3d& start,
                                               const Vector3d& goal,
                                               int num_samples) {
    vector<Vector3d> boundary_points;
    
    Vector3d center = 0.5 * (start + goal);
    double semi_major_axis = 0.5 * (goal - start).norm() + sample_inflate_;
    
    // æ„å»ºæ¤­çƒåæ ‡ç³»
    Vector3d x_axis = (goal - start).normalized();
    Vector3d z_axis(0, 0, 1);
    Vector3d y_axis = x_axis.cross(z_axis).normalized();
    if (y_axis.norm() < 1e-3) {
        y_axis = Vector3d(1, 0, 0);
    }
    z_axis = x_axis.cross(y_axis).normalized();
    
    Matrix3d rotation;
    rotation.col(0) = x_axis;
    rotation.col(1) = y_axis;
    rotation.col(2) = z_axis;
    
    // éšæœºé‡‡æ ·
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    int valid_count = 0;
    int attempts = 0;
    int max_attempts = num_samples * 10;
    
    while (valid_count < num_samples && attempts < max_attempts) {
        attempts++;
        
        // åœ¨æ¤­çƒè¡¨é¢ï¼ˆshellï¼‰é‡‡æ ·ï¼šr âˆˆ [0.8, 1.0] * semi_major_axis
        double theta = 2.0 * M_PI * dis(gen);
        double phi = acos(2.0 * dis(gen) - 1.0);
        double r = (0.8 + 0.2 * dis(gen)) * semi_major_axis; // è¾¹ç•Œå±‚
        
        Vector3d pt_local(
            r * sin(phi) * cos(theta),
            r * sin(phi) * sin(theta),
            r * cos(phi)
        );
        
        Vector3d pt_world = rotation * pt_local + center;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨è‡ªç”±ç©ºé—´ï¼ˆä½¿ç”¨æ›´å°çš„clearanceä»¥å¢åŠ æ¥å—ç‡ï¼‰
        if (isPointFree(pt_world, clearance_ * 0.8)) {
            boundary_points.push_back(pt_world);
            valid_count++;
        }
    }
    
    ROS_DEBUG("[TopoPRM] è¾¹ç•Œé‡‡æ ·: %d æ¬¡å°è¯•, %d ä¸ªæœ‰æ•ˆç‚¹", attempts, valid_count);
    
    return boundary_points;
}

bool TopoPRM::isPointFree(const Vector3d& pt, double min_clearance) {
    // æ£€æŸ¥æ˜¯å¦åœ¨åœ°å›¾èŒƒå›´å†…
    if (!grid_map_->isInMap(pt)) {
        return false;
    }
    
    // æ£€æŸ¥è·ç¦»éšœç¢ç‰©çš„è·ç¦»
    double dist = grid_map_->getDistance(pt);
    return dist > min_clearance;
}

// ============================================================================
// Week 2: å¯è§æ€§å›¾æ„å»º
// ============================================================================
void TopoPRM::buildVisibilityGraph(const Vector3d& start, const Vector3d& goal,
                                   const vector<Vector3d>& sample_points) {
    clearGraph();
    
    // åˆ›å»ºèµ·ç‚¹å’Œç»ˆç‚¹èŠ‚ç‚¹
    GraphNode* start_node = new GraphNode(start, 0);
    GraphNode* goal_node = new GraphNode(goal, 1);
    graph_nodes_.push_back(start_node);
    graph_nodes_.push_back(goal_node);
    
    // åˆ›å»ºé‡‡æ ·ç‚¹èŠ‚ç‚¹
    int node_id = 2;
    for (const auto& pt : sample_points) {
        GraphNode* node = new GraphNode(pt, node_id++);
        graph_nodes_.push_back(node);
    }
    
    // K value: optimized to 12 for balanced connectivity and search efficiency
    // åŸå› : K=18å¯¼è‡´å¹³å‡åº¦20.6ï¼Œå›¾è¿‡å¯†äº§ç”Ÿå¤§é‡ç»•è·¯ï¼›K=12å¯ä¿è¯è¿é€šæ€§åŒæ—¶é™ä½æœç´¢å¤æ‚åº¦
    int K = 12;
    int edge_count = 0;
    for (size_t i = 0; i < graph_nodes_.size(); ++i) {
        // æ”¶é›†æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„è·ç¦»
        vector<pair<double, int>> distances;
        for (size_t j = 0; j < graph_nodes_.size(); ++j) {
            if (i == j) continue;
            double dist = (graph_nodes_[i]->pos - graph_nodes_[j]->pos).norm();
            distances.push_back({dist, j});
        }
        
        // æ’åºå¹¶å–å‰ K ä¸ªæœ€è¿‘é‚»
        sort(distances.begin(), distances.end());
    int num_neighbors = min(K, (int)distances.size());
        
        // å¯¹æ¯ä¸ª KNN é‚»å±…æ£€æŸ¥å¯è§æ€§
        for (int k = 0; k < num_neighbors; ++k) {
            int j = distances[k].second;
            Vector3d p1 = graph_nodes_[i]->pos;
            Vector3d p2 = graph_nodes_[j]->pos;
            
            // æ£€æŸ¥å¯è§æ€§
            if (isLineCollisionFree(p1, p2)) {
                // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥ï¼ˆé¿å…é‡å¤ï¼‰
                bool already_connected = false;
                for (auto neighbor : graph_nodes_[i]->neighbors) {
                    if (neighbor->id == graph_nodes_[j]->id) {
                        already_connected = true;
                        break;
                    }
                }
                if (!already_connected) {
                    graph_nodes_[i]->neighbors.push_back(graph_nodes_[j]);
                    graph_nodes_[j]->neighbors.push_back(graph_nodes_[i]);
                    edge_count++;
                }
            }
        }
        
        // ğŸš€ P0 OPTIMIZED: å¦‚æœæœ¬èŠ‚ç‚¹è¿æ¥æ•°å¤ªå°‘ï¼Œå°è¯•åŸºäºåŠå¾„çš„å¤‡ä»½ç­–ç•¥æ”¾å®½è·ç¦»é™åˆ¶
        int connected_here = graph_nodes_[i]->neighbors.size();
        if (connected_here < 3) {
            double radius_thresh = search_radius_ * 1.5; // ğŸš€ æ”¾å®½å¤‡ä»½é˜ˆå€¼ 1.2â†’1.5
            for (size_t j = 0; j < graph_nodes_.size(); ++j) {
                if (i == j) continue;
                double dist = (graph_nodes_[i]->pos - graph_nodes_[j]->pos).norm();
                if (dist > radius_thresh) continue;
                // å¦‚æœå·²ç»è¿æ¥å°±è·³è¿‡
                bool already_connected = false;
                for (auto neighbor : graph_nodes_[i]->neighbors) {
                    if (neighbor->id == graph_nodes_[j]->id) {
                        already_connected = true;
                        break;
                    }
                }
                if (already_connected) continue;

                // å°è¯•è¿è¾¹
                Vector3d p1 = graph_nodes_[i]->pos;
                Vector3d p2 = graph_nodes_[j]->pos;
                if (isLineCollisionFree(p1, p2)) {
                    graph_nodes_[i]->neighbors.push_back(graph_nodes_[j]);
                    graph_nodes_[j]->neighbors.push_back(graph_nodes_[i]);
                    edge_count++;
                }
            }
        }
    }
    
    // âœ… GLOBAL FIX: å¢å¼ºå›¾è¯Šæ–­ä¿¡æ¯
    double avg_degree = graph_nodes_.empty() ? 0.0 : (2.0 * edge_count / graph_nodes_.size());
    ROS_INFO("[TopoPRM]   å¯è§æ€§å›¾æ„å»ºå®Œæˆ: KNN K=%d", K);
    ROS_INFO("[TopoPRM]   èŠ‚ç‚¹æ•°: %zu, è¾¹æ•°: %d, å¹³å‡åº¦: %.1f", 
             graph_nodes_.size(), edge_count, avg_degree);
    
    // ğŸ” NEW: èµ·ç‚¹/ç»ˆç‚¹è¿é€šæ€§æŠ¥å‘Š
    if (graph_nodes_.size() >= 2) {
        int start_degree = graph_nodes_[0]->neighbors.size();
        int goal_degree = graph_nodes_[1]->neighbors.size();
        ROS_INFO("[TopoPRM]   èµ·ç‚¹è¿æ¥æ•°: %d, ç»ˆç‚¹è¿æ¥æ•°: %d", start_degree, goal_degree);
    }
}

// ============================================================================
// Week 3: DFSå¤šè·¯å¾„æœç´¢
// ============================================================================
vector<vector<Vector3d>> TopoPRM::searchMultiplePaths(GraphNode* start_node, 
                                                      GraphNode* goal_node) {
    raw_paths_.clear();
    
    // ï¿½ NEW: è¿é€šæ€§è¯Šæ–­ - æå‰æ£€æµ‹èµ·ç‚¹/ç»ˆç‚¹å­¤ç«‹é—®é¢˜
    int start_degree = start_node->neighbors.size();
    int goal_degree = goal_node->neighbors.size();
    
    ROS_INFO("[TopoPRM] å›¾è¿é€šæ€§è¯Šæ–­: èµ·ç‚¹åº¦=%d, ç»ˆç‚¹åº¦=%d, æ€»èŠ‚ç‚¹=%zu", 
             start_degree, goal_degree, graph_nodes_.size());
    
    if (start_degree == 0 || goal_degree == 0) {
        ROS_WARN("[TopoPRM] âš ï¸ èµ·ç‚¹(åº¦=%d)æˆ–ç»ˆç‚¹(åº¦=%d)å­¤ç«‹,æ— æ³•æ‰§è¡ŒDFS,ç›´æ¥å›é€€Legacy",
                 start_degree, goal_degree);
        return {};  // è¿”å›ç©º,é¿å…æµªè´¹150msæ— æ•ˆæœç´¢
    }
    
    if (start_degree < 3 || goal_degree < 3) {
        ROS_WARN("[TopoPRM] âš ï¸ èµ·ç‚¹(åº¦=%d)æˆ–ç»ˆç‚¹(åº¦=%d)è¿é€šæ€§å·®,DFSå¯èƒ½å›°éš¾",
                 start_degree, goal_degree);
    }
    
    // ï¿½ğŸš€ P0 FIX: åˆå§‹åŒ–è¶…æ—¶æ§åˆ¶
    dfs_start_time_ = std::chrono::steady_clock::now();
    dfs_timeout_flag_ = false;
    
    vector<GraphNode*> visited;
    visited.push_back(start_node);
    
    depthFirstSearch(visited, goal_node);
    
    // è½¬æ¢ä¸ºVector3dè·¯å¾„
    vector<vector<Vector3d>> result_paths;
    for (const auto& node_path : raw_paths_) {
        result_paths.push_back(node_path);
    }
    
    // âœ… GLOBAL FIX: å¢å¼ºè¶…æ—¶æŠ¥å‘Š
    auto end_time = std::chrono::steady_clock::now();
    double elapsed_ms = std::chrono::duration<double, std::milli>(end_time - dfs_start_time_).count();
    if (dfs_timeout_flag_) {
        ROS_WARN("[TopoPRM] â±ï¸ DFSè¶…æ—¶ (%.1fms > %.1fms),å·²æ‰¾åˆ° %zu æ¡è·¯å¾„ - å›¾èŠ‚ç‚¹:%zu", 
                 elapsed_ms, MAX_DFS_TIME_MS, result_paths.size(), graph_nodes_.size());
    } else {
        ROS_INFO("[TopoPRM] âœ… DFSå®Œæˆ (%.1fms),æ‰¾åˆ° %zu æ¡åŸå§‹è·¯å¾„", 
                 elapsed_ms, result_paths.size());
    }
    
    return result_paths;
}

void TopoPRM::depthFirstSearch(vector<GraphNode*>& visited, GraphNode* goal_node) {
    // ğŸš€ P0 FIX: è¶…æ—¶æ£€æŸ¥ï¼ˆæ¯æ¬¡é€’å½’å¼€å§‹æ—¶æ£€æŸ¥ï¼‰
    auto now = std::chrono::steady_clock::now();
    double elapsed_ms = std::chrono::duration<double, std::milli>(now - dfs_start_time_).count();
    if (elapsed_ms > MAX_DFS_TIME_MS) {
        if (!dfs_timeout_flag_) {
            dfs_timeout_flag_ = true;
            ROS_WARN("[TopoPRM] DFSè¾¾åˆ°æ—¶é—´é™åˆ¶ (%.1fms)ï¼Œå½“å‰å·²æ‰¾åˆ° %zu æ¡è·¯å¾„", 
                     elapsed_ms, raw_paths_.size());
        }
        return;  // è¶…æ—¶ï¼Œæå‰è¿”å›
    }
    
    GraphNode* current = visited.back();
    
    // åˆ°è¾¾ç»ˆç‚¹
    if (current->id == goal_node->id) {
        vector<Vector3d> path;
        for (auto node : visited) {
            path.push_back(node->pos);
        }
        raw_paths_.push_back(path);
        
        // é™åˆ¶è·¯å¾„æ•°é‡
        if (raw_paths_.size() >= (size_t)max_raw_paths_) {
            return;
        }
        return;
    }
    
    // âœ… GLOBAL FIX: æ—©åœä¼˜åŒ– - é™åˆ°12æ¡(æ—¥å¿—æ˜¾ç¤ºè¶…æ—¶æ—¶å·²æœ‰12æ¡,15å¤ªé«˜)
    if (raw_paths_.size() >= 12) {
        return;  // 12æ¡raw â†’ å»é‡å~4-5æ¡,é¿å…è¶…æ—¶
    }
    
    // âœ… NEW: æ™ºèƒ½æ—©åœ - åŸºäºæ—¶é—´å’Œè´¨é‡æŠ˜è¡·
    auto current_time = std::chrono::steady_clock::now();
    double current_elapsed = std::chrono::duration<double, std::milli>(current_time - dfs_start_time_).count();
    if (raw_paths_.size() >= 8 && current_elapsed > 100.0) {
        ROS_DEBUG("[TopoPRM] æ™ºèƒ½æ—©åœ: å·²æ‰¾åˆ°%zuæ¡è·¯å¾„,è€—æ—¶%.1fms", raw_paths_.size(), current_elapsed);
        return;  // 8æ¡è·¯å¾„+100ms â†’ æå‰é€€å‡º,é¿å…è¾¹é™…æ”¶ç›Šé€’å‡
    }
    
    // é€’å½’æœç´¢é‚»å±…
    for (auto neighbor : current->neighbors) {
        // æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
        bool already_visited = false;
        for (auto v : visited) {
            if (v->id == neighbor->id) {
                already_visited = true;
                break;
            }
        }
        
        if (already_visited) continue;
        
        // âœ… GLOBAL FIX: æ·±åº¦é™åˆ¶é™ä½åˆ°15 (20â†’15: é¿å…è¶…é•¿ç»•è·¯)
        if (visited.size() > 15) continue;
        
        // é€’å½’
        visited.push_back(neighbor);
        depthFirstSearch(visited, goal_node);
        
        if (raw_paths_.size() >= (size_t)max_raw_paths_) {
            return;
        }
        
        visited.pop_back();
    }
}

// ============================================================================
// Week 4: æ‹“æ‰‘ç­‰ä»·æ€§å»é‡
// ============================================================================
vector<vector<Vector3d>> TopoPRM::pruneEquivalentPaths(
    const vector<vector<Vector3d>>& paths) {
    
    if (paths.empty()) return paths;
    
    vector<vector<Vector3d>> unique_paths;
    unique_paths.push_back(paths[0]);
    
    for (size_t i = 1; i < paths.size(); ++i) {
        bool is_unique = true;
        
        for (const auto& existing : unique_paths) {
            if (sameTopoPath(paths[i], existing)) {
                is_unique = false;
                break;
            }
        }
        
        if (is_unique) {
            unique_paths.push_back(paths[i]);
        }
    }
    
    ROS_DEBUG("[TopoPRM] æ‹“æ‰‘å»é‡: %zu â†’ %zu è·¯å¾„", paths.size(), unique_paths.size());
    
    return unique_paths;
}

bool TopoPRM::sameTopoPath(const vector<Vector3d>& path1, 
                           const vector<Vector3d>& path2) {
    // ğŸš€ OPTIMIZED: ä½¿ç”¨ Hausdorff è·ç¦»åˆ¤åŒï¼Œæ›´å®½å®¹ä¸”é«˜æ•ˆ
    vector<Vector3d> pts1 = discretizePath(path1, discretize_points_num_);
    vector<Vector3d> pts2 = discretizePath(path2, discretize_points_num_);
    
    // è®¡ç®— Hausdorff è·ç¦»
    double hausdorff_dist = 0.0;
    
    // max_{a in pts1} min_{b in pts2} ||a-b||
    for (const auto& a : pts1) {
        double min_dist = numeric_limits<double>::max();
        for (const auto& b : pts2) {
            min_dist = min(min_dist, (a - b).norm());
        }
        hausdorff_dist = max(hausdorff_dist, min_dist);
    }
    
    // max_{b in pts2} min_{a in pts1} ||a-b||
    for (const auto& b : pts2) {
        double min_dist = numeric_limits<double>::max();
        for (const auto& a : pts1) {
            min_dist = min(min_dist, (a - b).norm());
        }
        hausdorff_dist = max(hausdorff_dist, min_dist);
    }
    
    // âœ… GLOBAL FIX: ä¸¥æ ¼å»é‡é˜ˆå€¼ (0.035â†’0.025: å‡å°‘å†—ä½™æ‹“æ‰‘è·¯å¾„)
    double path_length = pathLength(path1);
    double threshold = max(0.25, path_length * 0.025);

    ROS_DEBUG("[TopoPRM] sameTopoPath: hausdorff=%.3f, threshold=%.3f, path_len=%.3f",
              hausdorff_dist, threshold, path_length);

    return hausdorff_dist < threshold;
}

vector<Vector3d> TopoPRM::discretizePath(const vector<Vector3d>& path, int pt_num) {
    if (path.size() < 2) return path;
    
    // è®¡ç®—è·¯å¾„é•¿åº¦
    vector<double> lengths;
    lengths.push_back(0.0);
    for (size_t i = 0; i < path.size() - 1; ++i) {
        double len = (path[i+1] - path[i]).norm();
        lengths.push_back(lengths.back() + len);
    }
    double total_length = lengths.back();
    
    // å‡åŒ€é‡‡æ ·
    vector<Vector3d> discretized;
    for (int i = 0; i < pt_num; ++i) {
        double target_len = total_length * i / (pt_num - 1);
        
        // æ‰¾åˆ°å¯¹åº”çš„æ®µ
        size_t seg_idx = 0;
        for (size_t j = 0; j < lengths.size() - 1; ++j) {
            if (target_len >= lengths[j] && target_len <= lengths[j+1]) {
                seg_idx = j;
                break;
            }
        }
        
        // æ’å€¼
        double lambda = (target_len - lengths[seg_idx]) / 
                       (lengths[seg_idx+1] - lengths[seg_idx]);
        Vector3d pt = (1 - lambda) * path[seg_idx] + lambda * path[seg_idx+1];
        discretized.push_back(pt);
    }
    
    return discretized;
}

// ============================================================================
// è¾…åŠ©å‡½æ•°: è·¯å¾„é€‰æ‹©
// ============================================================================
vector<vector<Vector3d>> TopoPRM::selectShortPaths(
    const vector<vector<Vector3d>>& paths) {
    
    if (paths.empty()) return paths;
    
    vector<vector<Vector3d>> short_paths;
    
    // æ‰¾åˆ°æœ€çŸ­è·¯å¾„
    int shortest_idx = shortestPathIndex(paths);
    double min_length = pathLength(paths[shortest_idx]);
    
    // é€‰æ‹©é•¿åº¦åœ¨é˜ˆå€¼å†…çš„è·¯å¾„
    for (const auto& path : paths) {
        double len = pathLength(path);
        if (len < min_length * ratio_to_short_ && short_paths.size() < (size_t)reserve_num_) {
            short_paths.push_back(path);
        }
    }
    
    // å¦‚æœå¤ªå°‘ï¼Œè‡³å°‘ä¿ç•™æœ€çŸ­çš„
    if (short_paths.empty()) {
        short_paths.push_back(paths[shortest_idx]);
    }
    
    return short_paths;
}

int TopoPRM::shortestPathIndex(const vector<vector<Vector3d>>& paths) {
    int shortest_idx = 0;
    double min_length = std::numeric_limits<double>::max();
    
    for (size_t i = 0; i < paths.size(); ++i) {
        double len = pathLength(paths[i]);
        if (len < min_length) {
            min_length = len;
            shortest_idx = i;
        }
    }
    
    return shortest_idx;
}

double TopoPRM::pathLength(const vector<Vector3d>& path) {
    double length = 0.0;
    for (size_t i = 0; i < path.size() - 1; ++i) {
        length += (path[i+1] - path[i]).norm();
    }
    return length;
}

// ============================================================================
// Utility functions implementation
// ============================================================================

bool TopoPRM::isLineCollisionFree(const Vector3d& start, const Vector3d& end) {
    Vector3d dir = end - start;
    double dist = dir.norm();
    if (dist < 1e-6) return true;
    
    dir.normalize();
    
    for (double t = 0; t <= dist; t += collision_check_resolution_) {
        Vector3d point = start + t * dir;
        if (grid_map_->getInflateOccupancy(point)) {
            return false;
        }
    }
    return true;
}

double TopoPRM::calculatePathCost(const vector<Vector3d>& path) {
    if (path.size() < 2) return std::numeric_limits<double>::max();
    
    double length_cost = 0.0;
    for (size_t i = 0; i < path.size() - 1; ++i) {
        length_cost += (path[i + 1] - path[i]).norm();
    }
    
    double smoothness_cost = calculateSmoothnessCost(path);
    double obstacle_cost = calculateObstacleCost(path);
    
    return length_cost + 2.0 * smoothness_cost + 5.0 * obstacle_cost;
}

double TopoPRM::calculateSmoothnessCost(const vector<Vector3d>& path) {
    if (path.size() < 3) return 0.0;
    
    double smoothness_cost = 0.0;
    for (size_t i = 1; i < path.size() - 1; ++i) {
        Vector3d v1 = (path[i] - path[i - 1]).normalized();
        Vector3d v2 = (path[i + 1] - path[i]).normalized();
        double angle = acos(std::max(-1.0, std::min(1.0, v1.dot(v2))));
        smoothness_cost += angle;
    }
    return smoothness_cost;
}

double TopoPRM::calculateObstacleCost(const vector<Vector3d>& path) {
    double obstacle_cost = 0.0;
    
    for (const auto& point : path) {
        // Check distance to nearest obstacle
        double min_dist = std::numeric_limits<double>::max();
        
        // Sample around the point to find nearest obstacle
        for (double dx = -search_radius_; dx <= search_radius_; dx += step_size_) {
            for (double dy = -search_radius_; dy <= search_radius_; dy += step_size_) {
                for (double dz = -search_radius_; dz <= search_radius_; dz += step_size_) {
                    Vector3d sample = point + Vector3d(dx, dy, dz);
                    if (grid_map_->getInflateOccupancy(sample)) {
                        double dist = Vector3d(dx, dy, dz).norm();
                        min_dist = std::min(min_dist, dist);
                    }
                }
            }
        }
        
        if (min_dist < search_radius_) {
            obstacle_cost += 1.0 / (min_dist + 0.1);
        }
    }
    
    return obstacle_cost;
}

TopoPath TopoPRM::selectBestPath(const vector<TopoPath>& paths) {
    if (paths.empty()) {
        return TopoPath();
    }
    
    // Return the path with minimum cost
    auto best_it = std::min_element(paths.begin(), paths.end(),
        [](const TopoPath& a, const TopoPath& b) {
            return a.cost < b.cost;
        });
    
    return *best_it;
}

void TopoPRM::visualizeTopoPaths(const vector<TopoPath>& paths) {
    ROS_INFO("[TopoPRM] Visualizing %zu topological paths with frame_id: %s", paths.size(), frame_id_.c_str());
    
    visualization_msgs::MarkerArray marker_array;
    
    // Clear previous markers
    visualization_msgs::Marker clear_marker;
    clear_marker.header.frame_id = frame_id_;
    clear_marker.header.stamp = ros::Time::now();
    clear_marker.action = visualization_msgs::Marker::DELETEALL;
    marker_array.markers.push_back(clear_marker);
    
    // Visualize each path with different colors
    for (size_t i = 0; i < paths.size() && i < 10; ++i) {
        visualization_msgs::Marker line_marker;
        line_marker.header.frame_id = frame_id_;
        line_marker.header.stamp = ros::Time::now();
        line_marker.ns = "topo_paths";
        line_marker.id = i;
        line_marker.type = visualization_msgs::Marker::LINE_STRIP;
        line_marker.action = visualization_msgs::Marker::ADD;
        line_marker.pose.orientation.w = 1.0;
        
        // Different colors for different paths
        if (i == 0) {
            line_marker.color.r = 1.0; line_marker.color.g = 0.0; line_marker.color.b = 0.0;
        } else if (i == 1) {
            line_marker.color.r = 0.0; line_marker.color.g = 1.0; line_marker.color.b = 0.0;
        } else if (i == 2) {
            line_marker.color.r = 0.0; line_marker.color.g = 0.0; line_marker.color.b = 1.0;
        } else {
            line_marker.color.r = 1.0; line_marker.color.g = 0.5; line_marker.color.b = 0.0;
        }
        line_marker.color.a = 0.9;
        line_marker.scale.x = 0.15;
        
        for (const auto& point : paths[i].path) {
            geometry_msgs::Point p;
            p.x = point.x();
            p.y = point.y();
            p.z = point.z();
            line_marker.points.push_back(p);
        }
        
        marker_array.markers.push_back(line_marker);
    }
    
    topo_paths_pub_.publish(marker_array);
}

// ğŸ”§ B-splineå¹³æ»‘å¯è§†åŒ–å‡½æ•°å·²ç§»é™¤,é¿å…path_searching â†” bspline_optå¾ªç¯ä¾èµ–
// /topo_paths_smoothç”±plan_manageå‘å¸ƒ (plan_manageå·²ä¾èµ–ä¸¤è€…,æ— å¾ªç¯ä¾èµ–)

} // namespace ego_planner
