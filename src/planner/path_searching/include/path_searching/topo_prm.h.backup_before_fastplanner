#ifndef _TOPO_PRM_H_
#define _TOPO_PRM_H_

#include <iostream>
#include <ros/ros.h>
#include <ros/console.h>
#include <Eigen/Eigen>
#include <plan_env/grid_map.h>
#include <queue>
#include <vector>
#include <memory>
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>
// B-splineå¯è§†åŒ–ç§»åˆ°planner_managerå¤„ç†,é¿å…å¾ªç¯ä¾èµ–

namespace ego_planner {

struct TopoPath {
    std::vector<Eigen::Vector3d> path;
    double cost;
    int path_id;
    
    TopoPath() : cost(0.0), path_id(-1) {}
    TopoPath(const std::vector<Eigen::Vector3d>& p, double c, int id) 
        : path(p), cost(c), path_id(id) {}
};

// ğŸš€ NEW: Graph node for PRM-based topology planning (Fast-Planner style)
struct GraphNode {
    Eigen::Vector3d pos;
    int id;
    std::vector<GraphNode*> neighbors;
    
    GraphNode() : id(-1) {}
    GraphNode(const Eigen::Vector3d& p, int node_id) : pos(p), id(node_id) {}
};

class TopoPRM {
private:
    GridMap::Ptr grid_map_;
    ros::Publisher topo_paths_pub_;           // æ‹“æ‰‘è·¯å¾„æŠ˜çº¿å¯è§†åŒ–
    std::string frame_id_;
    
    // Parameters
    double step_size_;
    double search_radius_;
    int max_sample_num_;
    double collision_check_resolution_;
    
    // ğŸš€ NEW: Fast-Planner PRM parameters
    int max_raw_paths_;           // æœ€å¤§åŸå§‹è·¯å¾„æ•° (DFSæœç´¢é™åˆ¶)
    int reserve_num_;             // ä¿ç•™çš„æœ€çŸ­è·¯å¾„æ•°
    double clearance_;            // èŠ‚ç‚¹æœ€å°å®‰å…¨è·ç¦»
    double sample_inflate_;       // æ¤­çƒé‡‡æ ·è†¨èƒ€ç³»æ•°
    double ratio_to_short_;       // ç›¸å¯¹æœ€çŸ­è·¯å¾„çš„é•¿åº¦æ¯”ç‡é˜ˆå€¼
    int discretize_points_num_;   // æ‹“æ‰‘å»é‡æ—¶çš„ç¦»æ•£åŒ–ç‚¹æ•°
    
    // ğŸš€ NEW: PRM graph data structures
    std::vector<GraphNode*> graph_nodes_;
    std::vector<std::vector<Eigen::Vector3d>> raw_paths_;
    
    // ğŸš€ P0 NEW: DFSè¶…æ—¶æ§åˆ¶
    std::chrono::steady_clock::time_point dfs_start_time_;
    bool dfs_timeout_flag_;
    const double MAX_DFS_TIME_MS = 400.0;  // Increased to 400ms to allow more search time in complex graphs
    
    // Shared utility functions
    bool isPathValid(const std::vector<Eigen::Vector3d>& path);
    bool isLineCollisionFree(const Eigen::Vector3d& start, const Eigen::Vector3d& end);
    
    // ğŸš€ NEW: Fast-Planner PRM methods
    // Week 1: æ¤­çƒé‡‡æ ·
    std::vector<Eigen::Vector3d> sampleFreeSpaceInEllipsoid(
        const Eigen::Vector3d& start, const Eigen::Vector3d& goal, int num_samples);
    // ğŸš€ P0 NEW: è¾¹ç•Œå±‚é‡‡æ ·
    std::vector<Eigen::Vector3d> sampleBoundaryLayer(
        const Eigen::Vector3d& start, const Eigen::Vector3d& goal, int num_samples);
    bool isPointFree(const Eigen::Vector3d& pt, double min_clearance);
    
    // Week 2: å¯è§æ€§å›¾æ„å»º
    void buildVisibilityGraph(const Eigen::Vector3d& start, const Eigen::Vector3d& goal,
                               const std::vector<Eigen::Vector3d>& sample_points);
    void clearGraph();
    
    // Week 3: DFSå¤šè·¯å¾„æœç´¢
    void depthFirstSearch(std::vector<GraphNode*>& visited, GraphNode* goal_node);
    std::vector<std::vector<Eigen::Vector3d>> searchMultiplePaths(
        GraphNode* start_node, GraphNode* goal_node);
    
    // Week 4: æ‹“æ‰‘å»é‡
    bool sameTopoPath(const std::vector<Eigen::Vector3d>& path1,
                      const std::vector<Eigen::Vector3d>& path2);
    std::vector<Eigen::Vector3d> discretizePath(const std::vector<Eigen::Vector3d>& path, int pt_num);
    std::vector<std::vector<Eigen::Vector3d>> pruneEquivalentPaths(
        const std::vector<std::vector<Eigen::Vector3d>>& paths);
    
    // è¾…åŠ©å‡½æ•°
    int shortestPathIndex(const std::vector<std::vector<Eigen::Vector3d>>& paths);
    double pathLength(const std::vector<Eigen::Vector3d>& path);
    std::vector<std::vector<Eigen::Vector3d>> selectShortPaths(
        const std::vector<std::vector<Eigen::Vector3d>>& paths);
    
    // Legacy functions removed (2025-11-12) - no longer needed after parameter optimization
    // Removed: findTopoPathsLegacy, generateAlternativePath, generateCircularPath, 
    //          generateVerticalPath, generateTangentPoints, estimateObstacleSize
    
    // Cost calculation
    double calculatePathCost(const std::vector<Eigen::Vector3d>& path);
    double calculateSmoothnessCost(const std::vector<Eigen::Vector3d>& path);
    double calculateObstacleCost(const std::vector<Eigen::Vector3d>& path);
    
    // Visualization
    void visualizeTopoPaths(const std::vector<TopoPath>& paths);
    // B-splineå¹³æ»‘å¯è§†åŒ–ç§»åˆ°planner_manager,é¿å…å¾ªç¯ä¾èµ–
    void publishPath(const std::vector<Eigen::Vector3d>& path, int id, 
                    double r, double g, double b, double scale = 0.1);

public:
    typedef std::shared_ptr<TopoPRM> Ptr;
    
    TopoPRM();
    ~TopoPRM();
    
    void init(ros::NodeHandle& nh, GridMap::Ptr grid_map);
    
    // Main interface
    bool searchTopoPaths(const Eigen::Vector3d& start, const Eigen::Vector3d& goal,
                        std::vector<TopoPath>& topo_paths);
    
    TopoPath selectBestPath(const std::vector<TopoPath>& paths);
    
    // Parameters
    void setStepSize(double step_size) { step_size_ = step_size; }
    void setSearchRadius(double radius) { search_radius_ = radius; }
    void setMaxSampleNum(int num) { max_sample_num_ = num; }
};

} // namespace ego_planner

#endif